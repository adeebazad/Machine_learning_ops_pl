import io
import base64
from datetime import datetime
from reportlab.lib import colors
from reportlab.lib.pagesizes import A4, letter
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, Image as RLImage, PageBreak, KeepTogether
from reportlab.lib.enums import TA_CENTER, TA_LEFT

class PDFReportGenerator:
    def __init__(self, buffer):
        self.buffer = buffer
        self.doc = SimpleDocTemplate(
            self.buffer,
            pagesize=A4,
            rightMargin=72,
            leftMargin=72,
            topMargin=72,
            bottomMargin=72
        )
        self.styles = getSampleStyleSheet()
        self._create_custom_styles()
        self.elements = []

    def _create_custom_styles(self):
        self.styles.add(ParagraphStyle(
            name='ReportTitle',
            parent=self.styles['Heading1'],
            fontSize=24,
            spaceAfter=30,
            alignment=TA_CENTER,
            textColor=colors.HexColor('#1e3a8a')  # Brand Blue
        ))
        
        self.styles.add(ParagraphStyle(
            name='SectionHeader',
            parent=self.styles['Heading2'],
            fontSize=16,
            spaceBefore=20,
            spaceAfter=10,
            textColor=colors.HexColor('#2563eb')
        ))

        self.styles.add(ParagraphStyle(
            name='MetricLabel',
            parent=self.styles['Normal'],
            fontSize=10,
            textColor=colors.gray
        ))

        self.styles.add(ParagraphStyle(
            name='MetricValue',
            parent=self.styles['Normal'],
            fontSize=14,
            fontName='Helvetica-Bold',
            textColor=colors.black
        ))
        
        self.styles.add(ParagraphStyle(
            name='ObservationText',
            parent=self.styles['Normal'],
            fontSize=11,
            leading=14,
            spaceAfter=10,
            textColor=colors.HexColor('#334155')
        ))

    def add_title_page(self, title, subtitle=None, author="AI Platform"):
        self.elements.append(Spacer(1, 2 * inch))
        self.elements.append(Paragraph(title, self.styles['ReportTitle']))
        if subtitle:
            self.elements.append(Paragraph(subtitle, self.styles['Normal']))
        
        self.elements.append(Spacer(1, 1 * inch))
        self.elements.append(Paragraph(f"Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M')}", self.styles['Normal']))
        self.elements.append(Paragraph(f"Generated by: {author}", self.styles['Normal']))
        self.elements.append(PageBreak())

    def add_section_header(self, text):
        self.elements.append(Paragraph(text, self.styles['SectionHeader']))

    def add_metrics_table(self, metrics):
        """
        metrics: list of dicts {'label': str, 'value': str/num}
        """
        if not metrics:
            return
            
        data = []
        # Create a grid of metrics (2 per row)
        row = []
        for m in metrics:
            # Cell content
            cell = [
                Paragraph(str(m.get('label', '')), self.styles['MetricLabel']),
                Paragraph(str(m.get('value', '')), self.styles['MetricValue'])
            ]
            row.append(cell)
            if len(row) == 3: # 3 cols
                data.append(row)
                row = []
        
        if row:
            while len(row) < 3:
                row.append(['', ''])
            data.append(row)

        if not data:
            return

        # Flatten logic for Table (ReportLab tables take simple list of lists, but we have Paragraphs)
        # Actually easier to just make a simple list of lists of Paragraphs
        
        # Simpler approach: List of [Label, Value] rows
        # Let's do a vertical list table for clarity if grid is hard
        table_data = [['Metric', 'Value']]
        for m in metrics:
            table_data.append([
                Paragraph(str(m.get('label', '')), self.styles['Normal']),
                Paragraph(str(m.get('value', '')), self.styles['BodyText'])
            ])

        t = Table(table_data, colWidths=[3*inch, 3*inch])
        t.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#f1f5f9')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.HexColor('#1e293b')),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('BACKGROUND', (0, 1), (-1, -1), colors.white),
            ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#e2e8f0')),
            ('PADDING', (0, 0), (-1, -1), 6),
        ]))
        self.elements.append(t)
        self.elements.append(Spacer(1, 0.2 * inch))

    def add_observation(self, text):
        if text:
            self.elements.append(Paragraph("<b>AI Observations:</b>", self.styles['Normal']))
            self.elements.append(Spacer(1, 4))
            self.elements.append(Paragraph(text, self.styles['ObservationText']))
            self.elements.append(Paragraph(text, self.styles['ObservationText']))
            self.elements.append(Spacer(1, 0.2 * inch))

    def add_data_snapshot(self, data):
        if not data:
            return
            
        # Limit columns if too many? For now take all keys from first row
        headers = list(data[0].keys())
        
        # Prepare table data: Headers + Rows
        table_data = [[Paragraph(f"<b>{h}</b>", self.styles['Normal']) for h in headers]]
        
        for row in data:
            row_data = []
            for h in headers:
                val = str(row.get(h, ''))
                # Truncate very long values
                if len(val) > 50: val = val[:47] + "..."
                row_data.append(Paragraph(val, self.styles['Normal']))
            table_data.append(row_data)

        # Calculate col widths based on page width
        # A4 width = ~8.27 inch. Margins 72pt (1 inch) left/right.
        # Usable width = ~6 inch.
        # Simple equal width for now
        col_width = (6.0 / len(headers)) * inch if headers else 1*inch
        
        # Define style
        ts = TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#1e40af')), # Dark Blue Header
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),              # White Text on Header
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 7), # Smaller font for density
            ('BOTTOMPADDING', (0, 0), (-1, 0), 8),
            ('TOPPADDING', (0, 0), (-1, 0), 8),
            ('GRID', (0, 0), (-1, -1), 0.5, colors.HexColor('#cbd5e1')),
            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.HexColor('#f8fafc')]), # Striped rows
            ('LEFTPADDING', (0, 0), (-1, -1), 4),
            ('RIGHTPADDING', (0, 0), (-1, -1), 4),
            ('VALIGN', (0, 0), (-1, -1), 'TOP'),
        ])
        
        t = Table(table_data, colWidths=[col_width]*len(headers))
        t.setStyle(ts)
        
        self.elements.append(Paragraph("<b>Data Snapshot (First 50 Rows)</b>", self.styles['Normal']))
        self.elements.append(Spacer(1, 4))
        self.elements.append(t)
        self.elements.append(Spacer(1, 0.2 * inch))
    
    def add_chart_section(self, chart_title, observations=None, image_base64=None, data_snapshot=None):
        content = []
        content.append(Paragraph(chart_title, self.styles['SectionHeader']))
        
        if image_base64:
            try:
                # Base64 decoding
                img_str = image_base64
                if ',' in img_str:
                    img_str = img_str.split(',')[1]
                
                image_data = base64.b64decode(img_str)
                image_stream = io.BytesIO(image_data)
                
                # Image aspect ratio usually 2:1 or 16:9 from frontend
                # Page width ~6 inch. Height ~3.5 inch keeps it reasonable.
                img = RLImage(image_stream, width=6*inch, height=3.5*inch)
                img.hAlign = 'LEFT'
                content.append(img)
                content.append(Spacer(1, 0.1 * inch))
            except Exception as e:
                print(f"Image render error: {e}")
                content.append(Paragraph(f"[Image Error: {str(e)}]", self.styles['Normal']))

        if observations:
            content.append(Paragraph("<b>AI Observations:</b>", self.styles['Normal']))
            content.append(Spacer(1, 4))
            content.append(Paragraph(observations, self.styles['ObservationText']))
            content.append(Spacer(1, 0.1 * inch))

        # Add to KeepTogether if it's small, otherwise append directly to elements
        # Snapshot table might be huge, so we should NOT put it in KeepTogether with image/title
        # if it spans pages.
        
        self.elements.append(KeepTogether(content))
        
        # Add Snapshot OUTSIDE of KeepTogether to allow page splitting
        if data_snapshot:
             self.add_data_snapshot(data_snapshot)
        
        self.elements.append(Spacer(1, 0.3 * inch))

    def build(self):
        self.doc.build(self.elements)

def generate_report_bytes(report_data: dict) -> bytes:
    """
    Main entry point.
    report_data = {
        "title": str,
        "description": str,
        "metrics": [{"label": str, "value": str}],
        "charts": [
            {"title": str, "observations": str, "type": str}
        ]
    }
    """
    buffer = io.BytesIO()
    generator = PDFReportGenerator(buffer)
    
    # Title Page
    generator.add_title_page(
        title=report_data.get("title", "Dashboard Report"),
        subtitle=report_data.get("description", "")
    )
    
    # Executive Summary / Global Metrics removed as per user request
    # Only Title Page -> Detailed Analysis
    
    # Detailed Charts Analysis
    if report_data.get("charts"):
        generator.add_section_header("Detailed Analysis")
        for chart in report_data["charts"]:
            generator.add_chart_section(
                chart_title=chart.get("title", "Untitled Chart"),
                observations=chart.get("observations"),
                image_base64=chart.get("image"),
                data_snapshot=chart.get("data_snapshot")
            )
            
    generator.build()
    buffer.seek(0)
    return buffer.getvalue()
